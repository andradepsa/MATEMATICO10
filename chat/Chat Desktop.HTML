<!DOCTYPE html>
<html lang="pt-br">
<head>

<!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
     RESTO DO SEU C√ìDIGO DO MENU - SEM ALTERA√á√ïES
     ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      background-color: #f4f4f4;
    }
    #root {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }
    .app-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background-color: #007bff;
      color: white;
      padding: 10px 20px;
      border-radius: 5px;
      margin-bottom: 20px;
    }
    .app-title {
      margin: 0;
      font-size: 24px;
    }
    .header-buttons {
      display: flex;
      gap: 10px;
    }
    .header-button {
      background: none;
      border: none;
      color: white;
      font-size: 18px;
      cursor: pointer;
    }
    .user-info-container {
      background-color: white;
      padding: 15px;
      border-radius: 5px;
      margin-bottom: 20px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    .username {
      font-weight: bold;
      color: #333;
    }
    .user-edit-button {
      background-color: #007bff;
      color: white;
      border: none;
      padding: 5px 10px;
      border-radius: 3px;
      cursor: pointer;
    }
    .user-name-form {
      display: flex;
      gap: 10px;
      align-items: center;
    }
    .user-name-form input {
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 3px;
      width: 200px;
    }
    .user-name-form button {
      background-color: #28a745;
      color: white;
      border: none;
      padding: 8px 15px;
      border-radius: 3px;
      cursor: pointer;
    }
    .user-name-form button:disabled {
      background-color: #ccc;
      cursor: not-allowed;
    }
    .peer-id-container {
      background-color: white;
      padding: 15px;
      border-radius: 5px;
      margin-bottom: 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    .peer-id-container button {
      background-color: #007bff;
      color: white;
      border: none;
      padding: 8px 15px;
      border-radius: 3px;
      cursor: pointer;
    }
    .chat-main-container {
      display: flex;
      gap: 20px;
      height: calc(100vh - 300px);
    }
    .conversations-list {
      width: 300px;
      background-color: white;
      border-radius: 5px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      overflow-y: auto;
    }
    .conversation-item {
      padding: 15px;
      border-bottom: 1px solid #eee;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      gap: 5px;
    }
    .conversation-item.selected {
      background-color: #e6f3ff;
    }
    .conversation-name {
      font-weight: bold;
      color: #333;
    }
    .conversation-peer-id {
      font-size: 12px;
      color: #666;
    }
    .chat-messages-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      background-color: white;
      border-radius: 5px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    .chat-messages {
      flex: 1;
      padding: 15px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .message-bubble {
      max-width: 70%;
      padding: 10px;
      border-radius: 10px;
      position: relative;
      word-wrap: break-word;
    }
    .message-bubble.sent {
      background-color: #007bff;
      color: white;
      align-self: flex-end;
    }
    .message-bubble.received {
      background-color: #e9ecef;
      color: #333;
      align-self: flex-start;
    }
    .chat-user-bubble {
      font-size: 12px;
      font-weight: bold;
      margin-bottom: 5px;
    }
    .message-timestamp {
      font-size: 10px;
      color: #999;
      margin-top: 5px;
      text-align: right;
    }
    .file-link {
      color: inherit;
      text-decoration: underline;
    }
    .audio-player {
      width: 200px;
      margin-top: 5px;
    }
    .reply-private-button {
      font-size: 10px;
      background: none;
      border: none;
      color: #007bff;
      cursor: pointer;
      margin-top: 5px;
      display: flex;
      align-items: center;
      gap: 5px;
    }
    .chat-input-container {
      display: flex;
      padding: 10px;
      border-top: 1px solid #eee;
      gap: 10px;
      align-items: center;
    }
    .voice-button {
      padding: 8px;
      background-color: #4CAF50;
      color: white;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .voice-button.recording {
      background-color: #ff5722;
      animation: pulse 1s infinite;
    }
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }
    .voice-button:disabled {
      background-color: #ccc;
      cursor: not-allowed;
    }
    .chat-input-container button {
      padding: 8px;
      background-color: #007bff;
      color: white;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .chat-input-container button:disabled {
      background-color: #ccc;
      cursor: not-allowed;
    }
    .message-input-container {
      flex: 1;
      position: relative;
      display: flex;
      align-items: center;
    }
    .emoji-button {
      background: none;
      border: none;
      font-size: 20px;
      cursor: pointer;
      margin-right: 5px;
    }
    .message-input {
      width: 100%;
      padding: 8px 40px 8px 40px;
      border: 1px solid #ddd;
      border-radius: 20px;
      outline: none;
    }
    .message-input:disabled {
      background-color: #f4f4f4;
      cursor: not-allowed;
    }
    .emoji-panel {
      position: absolute;
      bottom: 50px;
      left: 0;
      background-color: white;
      border: 1px solid #ddd;
      border-radius: 5px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      width: 300px;
      max-height: 200px;
      display: flex;
      flex-direction: column;
    }
    .emoji-panel-header {
      background-color: #007bff;
      color: white;
      padding: 5px 10px;
      font-weight: bold;
    }
    .emoji-panel-content {
      display: flex;
      flex-wrap: wrap;
      padding: 10px;
      overflow-y: auto;
    }
    .emoji-item {
      font-size: 24px;
      padding: 5px;
      cursor: pointer;
    }
    .emoji-panel-footer {
      padding: 5px 10px;
      border-top: 1px solid #ddd;
    }
    .barra-rolagem-label {
      font-size: 12px;
      color: #666;
    }
    .contact-form {
      background-color: white;
      padding: 15px;
      border-radius: 5px;
      margin-bottom: 20px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    .contact-form-row {
      display: flex;
      gap: 10px;
      align-items: flex-start;
    }
    .contact-form input {
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 3px;
      flex: 1;
    }
    .contact-form button {
      background-color: #28a745;
      color: white;
      border: none;
      padding: 8px 15px;
      border-radius: 3px;
      cursor: pointer;
    }
    .connected-peers {
      background-color: white;
      padding: 15px;
      border-radius: 5px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    .peer-item {
      padding: 10px;
      border-bottom: 1px solid #eee;
      display: flex;
      align-items: center;
      cursor: pointer;
    }
    .peer-item:last-child {
      border-bottom: none;
    }
    .peer-item button {
      background-color: #dc3545;
      color: white;
      border: none;
      padding: 5px 10px;
      border-radius: 3px;
      cursor: pointer;
    }
    .error-message {
      background-color: #f8d7da;
      color: #721c24;
      padding: 20px;
      border-radius: 5px;
      text-align: center;
      margin: 20px;
    }
    .error-message button {
      background-color: #dc3545;
      color: white;
      border: none;
      padding: 8px 15px;
      border-radius: 3px;
      cursor: pointer;
      margin-top: 10px;
    }
    .progress-container {
      margin-top: 5px;
    }
    .progress-bar {
      width: 100%;
      background-color: #f0f0f0;
      border-radius: 5px;
      overflow: hidden;
    }
    .progress {
      height: 5px;
      background-color: #007bff;
      transition: width: 0.3s ease;
    }
    .green-delete-icon {
      position: absolute;
      top: 5px;
      right: 5px;
      color: #28a745;
      cursor: pointer;
      font-size: 14px;
    }
    .green-delete-icon:hover {
      color: #218838;
    }
    .video-container {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      margin-bottom: 20px;
    }
    .video-player, .local-video-player {
      width: 320px;
      height: 240px;
      background-color: #000;
      border-radius: 5px;
    }
    .local-video-player {
      border: 2px solid #007bff;
    }
    .video-label {
      font-size: 14px;
      font-weight: bold;
      margin-bottom: 5px;
    }
    .audio-call-container {
      background-color: white;
      padding: 15px;
      border-radius: 5px;
      margin-bottom: 20px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    .call-end-button {
      background-color: #dc3545;
      color: white;
      border: none;
      padding: 5px 10px;
      border-radius: 3px;
      cursor: pointer;
    }
  
body.dark-mode {
  background-color: #121212;
  color: #e0e0e0;
}

.dark-mode .app-header {
  background-color: #1f1f1f;
}

.dark-mode .user-info-container,
.dark-mode .peer-id-container,
.dark-mode .contact-form,
.dark-mode .connected-peers,
.dark-mode .chat-messages-container,
.dark-mode .conversations-list,
.dark-mode .audio-call-container,
.dark-mode .video-container {
  background-color: #1e1e1e;
  color: #e0e0e0;
}

.dark-mode .message-bubble.received {
  background-color: #2e2e2e;
  color: #e0e0e0;
}

.dark-mode .message-input {
  background-color: #333;
  color: #fff;
  border: 1px solid #555;
}

.dark-mode .emoji-panel {
  background-color: #2a2a2a;
  border-color: #444;
}

</style>
</head>
<body>





<script>!function(){console.log("üîí Verificando acesso...");const e=sessionStorage.getItem("fromIndex"),t=sessionStorage.getItem("authorized"),n=localStorage.getItem("lastAccess"),o=document.referrer;if(console.log("fromSession:",e,"authorized:",t,"lastAccess:",n,"referrer:",o),e||t||n&&Date.now()-parseInt(n)<3e5)return console.log("‚úÖ Acesso autorizado!"),void(sessionStorage.setItem("fromIndex","true"),sessionStorage.setItem("authorized","true"));if(o){const e=["k10.netlify.app","matematico10.com.br"];if(e.some(e=>o.includes(e)))return console.log("‚úÖ Acesso via referrer autorizado!"),void(sessionStorage.setItem("fromIndex","true"),sessionStorage.setItem("authorized","true"))}console.warn("‚õî Acesso negado - Redirecionando..."),window.location.replace("matematico10.com.br"===window.location.hostname?"https://matematico10.com.br/index.html":"https://k10.netlify.app/index.html")}();</script>




<div id="root"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/peerjs/1.5.1/peerjs.min.js"></script>

  <script type="text/babel">
    // ### 1. Estrutura HTML e Estiliza√ß√£o CSS
    // **Descri√ß√£o Geral**: Esta se√ß√£o cont√©m o c√≥digo HTML que define a estrutura da p√°gina e o CSS que estiliza a interface do aplicativo de chat P2P. Inclui a importa√ß√£o de bibliotecas externas e os estilos para os componentes visuais.
    //
    // - **T√≥pico: Estrutura HTML**
    //   - **Descri√ß√£o**: Define a estrutura b√°sica da p√°gina com um cont√™iner principal (`div#root`) onde o aplicativo React ser√° renderizado. Inclui meta tags para responsividade e codifica√ß√£o UTF-8, al√©m de links para bibliotecas externas (Font Awesome, React, PeerJS).
    //
    // - **T√≥pico: Estiliza√ß√£o CSS**
    //   - **Descri√ß√£o**: Cont√©m regras CSS para estilizar a interface, incluindo layout, cores, sombras, anima√ß√µes (como o efeito de pulsar no bot√£o de grava√ß√£o) e responsividade. Estiliza componentes como cabe√ßalho, lista de contatos, √°rea de mensagens, bot√µes, e players de m√≠dia.
    //
    // - **T√≥pico: Importa√ß√£o de Depend√™ncias**
    //   - **Descri√ß√£o**: Inclui scripts para React, ReactDOM, Babel (para transpilar JSX), e PeerJS (para comunica√ß√£o P2P). Esses scripts s√£o carregados via CDN para habilitar as funcionalidades do aplicativo.
    //
    // FIM

    // ### 2. Configura√ß√£o Inicial e Gerenciamento de Erros
    // **Descri√ß√£o Geral**: Esta se√ß√£o inicializa o script React e define o componente `ErrorBoundary` para capturar erros na renderiza√ß√£o, al√©m de implementar o gerenciamento de identificadores persistentes para conex√µes P2P.
    //
    // - **T√≥pico: Inicializa√ß√£o do Script**
    //   - **Descri√ß√£o**: Inicia o script com um log de depura√ß√£o e importa hooks do React (`useState`, `useEffect`, `useRef`, `useMemo`) necess√°rios para o gerenciamento de estado e efeitos colaterais.
    //
    // - **T√≥pico: Componente ErrorBoundary**
    //   - **Descri√ß√£o**: Um componente React que captura erros durante a renderiza√ß√£o e exibe uma mensagem de erro amig√°vel com a op√ß√£o de recarregar a p√°gina. Usa `getDerivedStateFromError` para atualizar o estado com o erro capturado.
    //
    // - **T√≥pico: Gerenciamento de Identificadores Persistentes**
    //   - **Descri√ß√£o**: Implementa o hook `usePersistentId` para gerar ou carregar um ID √∫nico de 6 caracteres armazenado no `localStorage`. O ID √© usado para identificar o usu√°rio na rede PeerJS.
    //
    console.log("Script started loading");

    const { useState, useEffect, useRef, useMemo } = React;

    // PARTE 1: ErrorBoundary e gerenciamento de identificadores persistentes
    class ErrorBoundary extends React.Component {
      state = { error: null };

      static getDerivedStateFromError(error) {
        console.error("ErrorBoundary caught error:", error);
        return { error };
      }

      render() {
        if (this.state.error) {
          return (
            <div className="error-message">
              <h1>Erro na aplica√ß√£o</h1>
              <p>{this.state.error.message}</p>
              <p>Verifique o console do navegador para mais detalhes.</p>
            </div>
          );
        }
        return this.props.children;
      }
    }










    const PEER_ID_STORAGE_KEY = 'p2pChatClientId';
    const MESSAGES_STORAGE_KEY = 'p2pChatMessages';

    const usePersistentId = () => {
      const [peerId, setPeerId] = useState('');

      const generateId = () => {
        const chars = 'ABCDEFGHJKMNPQRSTUVWXYZ23456789';
        const buffer = new Uint8Array(6);
        crypto.getRandomValues(buffer);
        return Array.from(buffer)
          .map(b => chars[b % chars.length])
          .join('');
      };

      useEffect(() => {
        console.log("usePersistentId: Loading or generating ID");
        const loadOrGenerateId = () => {
          const savedId = localStorage.getItem(PEER_ID_STORAGE_KEY);
          if (savedId) {
            console.log("usePersistentId: Loaded saved ID:", savedId);
            setPeerId(savedId);
          } else {
            const newId = generateId();
            console.log("usePersistentId: Generated new ID:", newId);
            localStorage.setItem(PEER_ID_STORAGE_KEY, newId);
            setPeerId(newId);
          }
        };
        loadOrGenerateId();
      }, []);

      return [peerId, setPeerId];
    };











    //
    // FIM

    // ### 3. Componente de Grava√ß√£o de Voz
    // **Descri√ß√£o Geral**: Esta se√ß√£o define o componente `VoiceRecorder`, respons√°vel por gravar √°udio do microfone do usu√°rio e enviar o arquivo gravado para o contato selecionado.
    //
    // - **T√≥pico: Estado e Refer√™ncias**
    //   - **Descri√ß√£o**: Usa `useState` para gerenciar o estado de grava√ß√£o (`isRecording`) e `useRef` para armazenar o objeto `MediaRecorder` e os fragmentos de √°udio coletados (`audioChunksRef`).
    //
    // - **T√≥pico: In√≠cio da Grava√ß√£o**
    //   - **Descri√ß√£o**: A fun√ß√£o `startRecording` solicita acesso ao microfone via `navigator.mediaDevices.getUserMedia`, inicializa o `MediaRecorder`, e configura eventos para coletar dados de √°udio e processar o arquivo final.
    //
    // - **T√≥pico: Parada da Grava√ß√£o**
    //   - **Descri√ß√£o**: A fun√ß√£o `stopRecording` interrompe a grava√ß√£o, cria um `Blob` com os fragmentos de √°udio coletados, e chama a fun√ß√£o de callback `onRecordingComplete` com o arquivo resultante.
    //
    // - **T√≥pico: Interface do Usu√°rio**
    //   - **Descri√ß√£o**: Renderiza um bot√£o circular que alterna entre os estados de grava√ß√£o e parada, com anima√ß√£o de pulsar durante a grava√ß√£o e desativa√ß√£o quando n√£o permitido.
    //
    // PARTE 2: Componente para grava√ß√£o de voz
    const VoiceRecorder = ({ onRecordingComplete, disabled, selectedContact }) => {
      const [isRecording, setIsRecording] = useState(false);
      const mediaRecorderRef = useRef(null);
      const audioChunksRef = useRef([]);

      const startRecording = async () => {
        try {
          console.log("VoiceRecorder: Starting recording");
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          mediaRecorderRef.current = new MediaRecorder(stream);

          mediaRecorderRef.current.ondataavailable = (event) => {
            if (event.data.size > 0) {
              audioChunksRef.current.push(event.data);
            }
          };

          mediaRecorderRef.current.onstop = () => {
            if (audioChunksRef.current.length === 0) {
              console.error("VoiceRecorder: No audio data collected");
              return;
            }

            const audioBlob = new Blob(audioChunksRef.current, { type: 'audio/webm' });
            console.log("VoiceRecorder: Recording stopped, blob size:", audioBlob.size);
            onRecordingComplete(audioBlob, selectedContact);
            audioChunksRef.current = [];

            stream.getTracks().forEach(track => track.stop());
          };

          audioChunksRef.current = [];
          mediaRecorderRef.current.start(200);
          setIsRecording(true);
        } catch (err) {
          console.error("VoiceRecorder: Error accessing microphone:", err);
          alert('Erro ao acessar o microfone: ' + err.message);
        }
      };

      const stopRecording = () => {
        if (mediaRecorderRef.current && isRecording) {
          try {
            mediaRecorderRef.current.stop();
            console.log("VoiceRecorder: Stopping recording");
          } catch (err) {
            console.error("VoiceRecorder: Error stopping media recorder:", err);
          }
          setIsRecording(false);
        }
      };

      const toggleRecording = () => {
        if (isRecording) {
          stopRecording();
        } else {
          startRecording();
        }
      };

      return (
        <button
          className={`voice-button ${isRecording ? 'recording' : ''}`}
          onClick={toggleRecording}
          disabled={disabled}
          title="Gravar √°udio"
        >
          <i className="fas fa-microphone button-icon"></i>
        </button>
      );
    };
    //
    // FIM

    // ### 4. Tela de Gerenciamento de Contatos
    // **Descri√ß√£o Geral**: Esta se√ß√£o define o componente `ContactsScreen`, que permite ao usu√°rio adicionar, remover e selecionar contatos para iniciar conversas.
    //
    // - **T√≥pico: Estado e Valida√ß√£o**
    //   - **Descri√ß√£o**: Gerencia estados para nome e ID do novo contato, al√©m de mensagens de erro para valida√ß√£o. A fun√ß√£o `validateForm` verifica se os campos est√£o preenchidos antes de adicionar um contato.
    //
    // - **T√≥pico: Adi√ß√£o de Contatos**
    //   - **Descri√ß√£o**: A fun√ß√£o `handleAddContact` adiciona um novo contato √† lista e ao `localStorage` ap√≥s valida√ß√£o, limpando os campos do formul√°rio.
    //
    // - **T√≥pico: Remo√ß√£o de Contatos**
    //   - **Descri√ß√£o**: A fun√ß√£o `handleRemoveContact` remove um contato da lista e atualiza o `localStorage`, garantindo que a interface reflita a mudan√ßa.
    //
    // - **T√≥pico: Interface do Usu√°rio**
    //   - **Descri√ß√£o**: Renderiza um formul√°rio para adicionar contatos e uma lista de contatos existentes, com bot√µes para remover e selecionar contatos. Inclui navega√ß√£o para voltar √† tela principal.
    //
    // PARTE 3: Tela de gerenciamento de contatos
    const ContactsScreen = ({ contacts, setContacts, onBack, onSelectContact }) => {
      const [newName, setNewName] = useState('');
      const [newPeerId, setNewPeerId] = useState('');
      const [nameError, setNameError] = useState('');
      const [idError, setIdError] = useState('');

      const validateForm = () => {
        let isValid = true;

        if (!newName.trim()) {
          setNameError('Nome √© obrigat√≥rio');
          isValid = false;
        } else {
          setNameError('');
        }

        if (!newPeerId.trim()) {
          setIdError('ID √© obrigat√≥rio');
          isValid = false;
        } else {
          setIdError('');
        }

        return isValid;
      };

      const handleAddContact = (e) => {
        e.preventDefault();

        if (validateForm()) {
          const newContact = { name: newName, peerId: newPeerId };
          console.log("ContactsScreen: Adding contact:", newContact);
          setContacts(prev => {
            const updated = [...prev, newContact];
            localStorage.setItem('p2pContacts', JSON.stringify(updated));
            return updated;
          });
          setNewName('');
          setNewPeerId('');
        }
      };

      const handleRemoveContact = (peerId, e) => {
        e.stopPropagation();
        console.log("ContactsScreen: Removing contact with peerId:", peerId);
        setContacts(prev => {
          const updated = prev.filter(c => c.peerId !== peerId);
          localStorage.setItem('p2pContacts', JSON.stringify(updated));
          return updated;
        });
      };

      return (
        <div>
          <button onClick={onBack} style={{ marginBottom: '20px' }}>
            ‚Üê Voltar
          </button>
          <h2>Lista de Contatos</h2>

          <form className="contact-form" onSubmit={handleAddContact}>
            <div className="contact-form-row">
              <div style={{ display: 'flex', flexDirection: 'column' }}>
                <input
                  type="text"
                  placeholder="Nome do contato"
                  value={newName}
                  onChange={(e) => setNewName(e.target.value)}
                  style={{ borderColor: nameError ? 'red' : '#ddd' }}
                />
                {nameError && <span style={{ color: 'red', fontSize: '12px' }}>{nameError}</span>}
              </div>

              <div style={{ display: 'flex', flexDirection: 'column' }}>
                <input
                  type="text"
                  placeholder="ID do contato"
                  value={newPeerId}
                  onChange={(e) => setNewPeerId(e.target.value)}
                  style={{ borderColor: idError ? 'red' : '#ddd' }}
                />
                {idError && <span style={{ color: 'red', fontSize: '12px' }}>{idError}</span>}
              </div>

              <button type="submit">Adicionar</button>
            </div>
          </form>

          <div className="connected-peers contacts-list">
            {contacts.length === 0 ? (
              <p>Nenhum contato adicionado ainda.</p>
            ) : (
              contacts.map((contact, i) => (
                <div
                  key={i}
                  className="peer-item"
                  onClick={() => onSelectContact(contact.peerId)}
                >
                  <span style={{ flex: 1 }}>
                    {contact.name} - {contact.peerId}
                  </span>
                  <button
                    onClick={(e) => handleRemoveContact(contact.peerId, e)}
                    style={{ marginLeft: '10px' }}
                  >
                    üóëÔ∏è
                  </button>
                </div>
              ))
            )}
          </div>
        </div>
      );
    };
    //
    // FIM

    // ### 5. Gerenciador de Chat
    // **Descri√ß√£o Geral**: Esta se√ß√£o define o componente `UpdatedChatManager`, respons√°vel por exibir e gerenciar as conversas, incluindo mensagens de texto, arquivos, √°udios, chamadas de voz e v√≠deo.
    //
    // - **T√≥pico: Filtragem e Formata√ß√£o**
    //   - **Descri√ß√£o**: Usa `useMemo` para filtrar mensagens do contato selecionado e formata timestamps para exibi√ß√£o. Garante que apenas mensagens relevantes sejam mostradas.
    //
    // - **T√≥pico: Envio de Mensagens**
    //   - **Descri√ß√£o**: A fun√ß√£o `sendDirectMessage` envia mensagens de texto para o contato selecionado via PeerJS, atualizando o estado e o `localStorage`. Verifica se o contato est√° conectado.
    //
    // - **T√≥pico: Gerenciamento de M√≠dia**
    //   - **Descri√ß√£o**: Gerencia streams de √°udio e v√≠deo, atualizando refer√™ncias para elementos de m√≠dia (`audioRefs`, `videoRefs`) e garantindo reprodu√ß√£o autom√°tica.
    //
    // - **T√≥pico: Interface do Usu√°rio**
    //   - **Descri√ß√£o**: Renderiza a lista de conversas, √°rea de mensagens, e controles para envio de mensagens, arquivos, √°udios, e chamadas. Inclui bot√µes para apagar mensagens e iniciar/encerrar chamadas.
    //
    // PARTE 4: Gerenciador de chat (UpdatedChatManager)
    const UpdatedChatManager = ({
      connections,
      messages,
      setMessages,
      contacts,
      userName,
      peerId,
      activeCalls,
      endCall,
      startVoiceCall,
      toggleVideoCall,
      remoteStreams,
      audioRefs,
      videoRefs,
      handleFileChange,
      fileInputRef,
      handleAudioRecording,
      newMessage,
      setNewMessage,
      showEmojiPanel,
      setShowEmojiPanel,
      populateEmojiPanel,
      getContactName,
      selectedContact,
      setSelectedContact,
      localVideoRef
    }) => {
      const messagesEndRef = useRef(null);

      const formatTime = (date) => {
        const hours = date.getHours().toString().padStart(2, '0');
        const minutes = date.getMinutes().toString().padStart(2, '0');
        const seconds = date.getSeconds().toString().padStart(2, '0');
        return `${hours}:${minutes}:${seconds}`;
      };

      const filteredMessages = useMemo(() => {
        if (selectedContact) {
          return messages.filter(msg =>
            (msg.sender === selectedContact && msg.recipient === 'you') ||
            (msg.sender === 'you' && msg.recipient === selectedContact)
          );
        }
        return [];
      }, [messages, selectedContact]);

      const sendDirectMessage = () => {
        if (!userName.trim()) {
          alert('Por favor, defina seu nome antes de enviar mensagens');
          return;
        }

        if (!newMessage.trim() || !selectedContact) {
          console.log("UpdatedChatManager: Cannot send message: no text or no selected contact");
          return;
        }

        const conn = connections.find(c => c.peer === selectedContact);
        if (!conn) {
          alert(`Contato ${getContactName(selectedContact)} n√£o est√° conectado no momento.`);
          return;
        }

        try {
          const timestamp = new Date();
          conn.send({
            type: 'message',
            text: newMessage,
            senderName: userName,
            direct: true,
            time: formatTime(timestamp)
          });

          const newMessageObj = {
            text: newMessage,
            sender: 'you',
            recipient: selectedContact,
            senderName: userName,
            time: formatTime(timestamp),
            type: 'text',
            direct: true,
            timestamp: timestamp.getTime()
          };

          setMessages(prev => {
            const updated = [...prev, newMessageObj];
            localStorage.setItem(MESSAGES_STORAGE_KEY, JSON.stringify(updated));
            return updated;
          });

          setNewMessage('');
        } catch (err) {
          console.error("UpdatedChatManager: Error sending direct message:", err);
          alert(`Erro ao enviar mensagem: ${err.message}`);
        }
      };

      const handleSendMessage = () => {
        if (selectedContact) {
          sendDirectMessage();
        }
      };

      const handlePrivateReply = (peerId) => {
        setSelectedContact(peerId);
      };

      const deleteMessage = (messageTimestamp) => {
        setMessages(prev => {
          const updated = prev.filter(msg => msg.timestamp !== messageTimestamp);
          localStorage.setItem(MESSAGES_STORAGE_KEY, JSON.stringify(updated));
          return updated;
        });
      };

      const deleteMessagesByContact = (peerId) => {
        setMessages(prev => {
          const updated = prev.filter(
            msg =>
              !(
                (msg.sender === peerId && msg.recipient === 'you') ||
                (msg.sender === 'you' && msg.recipient === peerId)
              )
          );
          localStorage.setItem(MESSAGES_STORAGE_KEY, JSON.stringify(updated));
          return updated;
        });
      };

      useEffect(() => {
        if (messagesEndRef.current) {
          messagesEndRef.current.scrollIntoView({ behavior: "smooth" });
        }
      }, [filteredMessages]);

      useEffect(() => {
        remoteStreams.forEach(({ peerId, stream, type }) => {
          if (type === 'voice') {
            const audioElement = audioRefs.current[peerId];
            if (audioElement && audioElement.srcObject !== stream) {
              console.log("UpdatedChatManager: Assigning audio stream for peer:", peerId);
              audioElement.srcObject = stream;
              audioElement.play().catch(e => console.warn("Audio play failed:", e));
            }
          } else if (type === 'video') {
            const videoElement = videoRefs.current[peerId];
            if (videoElement && videoElement.srcObject !== stream) {
              console.log("UpdatedChatManager: Assigning video stream for peer:", peerId);
              videoElement.srcObject = stream;
              videoElement.play().catch(e => console.warn("Video play failed:", e));
            }
          }
        });
        return () => {
          Object.values(audioRefs.current).forEach(audio => { if (audio) audio.srcObject = null; });
          Object.values(videoRefs.current).forEach(video => { if (video) video.srcObject = null; });
        };
      }, [remoteStreams]);

      return (
        <div>
          <div className="chat-main-container">
            <div className="conversations-list">
              <h4 style={{ padding: '10px', margin: '0', borderBottom: '1px solid #eee' }}>Conversas</h4>
              {connections.map((conn, i) => {
                const isSelected = selectedContact === conn.peer;
                const hasActiveVoiceCallWithPeer = activeCalls.some(c => c.peerId === conn.peer && c.type === 'voice');
                return (
                  <div
                    key={i}
                    className={`conversation-item ${isSelected ? 'selected' : 'unselected'}`}
                    onClick={() => setSelectedContact(conn.peer)}
                  >
                    <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>
                      <div>
                        <div className="conversation-name">{getContactName(conn.peer)}</div>
                        <div className="conversation-peer-id">{conn.peer}</div>
                      </div>
                      <div
                        className="green-delete-icon"
                        onClick={(e) => {
                          e.stopPropagation();
                          deleteMessagesByContact(conn.peer);
                        }}
                        title="Apagar todas as mensagens deste contato"
                      >
                        <i className="fas fa-trash"></i>
                      </div>
                    </div>
                    <div style={{ display: 'flex', gap: '5px', marginTop: '5px' }}>
                      {hasActiveVoiceCallWithPeer ? (
                        <button
                          onClick={(e) => { e.stopPropagation(); endCall(conn.peer, 'voice'); }}
                          style={{ padding: '4px', background: '#ff5722', width: '30px', height: '30px', borderRadius: '50%' }}
                          title="Encerrar chamada de voz"
                        >
                          <i className="fas fa-phone-slash"></i>
                        </button>
                      ) : (
                        <button
                          onClick={(e) => { e.stopPropagation(); startVoiceCall(conn.peer); }}
                          style={{ padding: '4px', background: '#4CAF50', width: '30px', height: '30px', borderRadius: '50%' }}
                          title="Iniciar chamada de voz"
                        >
                          <i className="fas fa-phone"></i>
                        </button>
                      )}
                      <button
                        onClick={(e) => {
                          e.stopPropagation();
                          toggleVideoCall(conn.peer);
                        }}
                        style={{
                          padding: '4px',
                          background: activeCalls.some(c => c.peerId === conn.peer && c.type === 'video' && c.localStream)
                            ? '#ff5722'
                            : '#4CAF50',
                          width: '30px',
                          height: '30px',
                          borderRadius: '50%',
                        }}
                        title={activeCalls.some(c => c.peerId === conn.peer && c.type === 'video' && c.localStream)
                          ? "Desligar C√¢mera"
                          : "Ligar C√¢mera"}
                      >
                        <i className={`fas ${activeCalls.some(c => c.peerId === conn.peer && c.type === 'video' && c.localStream)
                          ? 'fa-video-slash'
                          : 'fa-video'}`}></i>
                      </button>
                    </div>
                  </div>
                );
              })}
            </div>
            <div className="chat-messages-container">
              <div className="chat-messages">
                {filteredMessages.map((msg, i) => (
                  <div key={msg.timestamp || i} className={`message-bubble ${msg.sender === 'you' ? 'sent' : 'received'}`}>
                    <div className="chat-user-bubble">
                      {msg.sender === 'you' ? userName : getContactName(msg.sender)}
                    </div>
                    {msg.type === 'text' ? (
                      <div>{msg.text}</div>
                    ) : msg.type === 'file' ? (
                      <div>
                        {msg.fileData ? (
                          <a href={msg.fileData} download={msg.fileName} className="file-link">
                            {msg.fileName}
                          </a>
                        ) : (
                          <span>{msg.fileName}</span>
                        )}
                        {(msg.receiving || msg.sending) && (
                          <div className="progress-container">
                            <div className="progress-bar">
                              <div className="progress" style={{ width: `${msg.progress}%` }} />
                            </div>
                          </div>
                        )}
                      </div>
                    ) : msg.type === 'audio' && (
                      <div>
                        {msg.audioData ? (
                          <audio controls src={msg.audioData} className="audio-player" />
                        ) : (
                          <span>√Åudio</span>
                        )}
                        {(msg.receiving || msg.sending) && (
                          <div className="progress-container">
                            <div className="progress-bar">
                              <div className="progress" style={{ width: `${msg.progress}%` }} />
                            </div>
                          </div>
                        )}
                      </div>
                    )}
                    <div className="message-timestamp">{msg.time}</div>
                    {msg.sender !== 'you' && !selectedContact && (
                      <button
                        className="reply-private-button"
                        onClick={() => handlePrivateReply(msg.sender)}
                      >
                        Responder em privado <i className="fas fa-reply"></i>
                      </button>
                    )}
                    <div
                      className="green-delete-icon"
                      onClick={() => deleteMessage(msg.timestamp)}
                      title="Remover mensagem"
                    >
                      <i className="fas fa-trash"></i>
                    </div>
                  </div>
                ))}
                <div ref={messagesEndRef} />
              </div>
              <div className="chat-input-container">
                <VoiceRecorder
                  onRecordingComplete={handleAudioRecording}
                  disabled={!selectedContact || !connections.some(c => c.peer === selectedContact)}
                  selectedContact={selectedContact}
                />
                <button
                  onClick={() => fileInputRef.current.click()}
                  disabled={!selectedContact || !connections.some(c => c.peer === selectedContact)}
                  title="Enviar arquivo"
                >
                  <i className="fas fa-paperclip"></i>
                </button>
                <div className="message-input-container">
                  <button
                    className="emoji-button"
                    onClick={() => setShowEmojiPanel(!showEmojiPanel)}
                    title="Emojis"
                  >
                    üòä
                  </button>
                  <input
                    type="text"
                    value={newMessage}
                    onChange={(e) => setNewMessage(e.target.value)}
                    placeholder={
                      selectedContact
                        ? `Mensagem para ${getContactName(selectedContact)}...`
                        : "Selecione um contato..."
                    }
                    onKeyPress={(e) => {
                      if (e.key === 'Enter' && selectedContact) {
                        handleSendMessage();
                      }
                    }}
                    className="message-input"
                    disabled={!selectedContact}
                  />
                  {showEmojiPanel && populateEmojiPanel()}
                </div>
                <button
                  onClick={handleSendMessage}
                  disabled={
                    !newMessage.trim() ||
                    !selectedContact ||
                    !connections.some(c => c.peer === selectedContact)
                  }
                  title="Enviar mensagem"
                >
                  <i className="fas fa-paper-plane"></i>
                </button>
              </div>
            </div>
          </div>
        </div>
      );
    };
    //
    // FIM

    // ### 6. Componente Principal App
    // **Descri√ß√£o Geral**: Esta se√ß√£o define o componente principal `App`, que integra todos os outros componentes e gerencia o estado geral do aplicativo, incluindo conex√µes PeerJS, mensagens, contatos, e chamadas.
    //
    // - **T√≥pico: Inicializa√ß√£o PeerJS**
    //   - **Descri√ß√£o**: Configura a conex√£o PeerJS com um ID persistente, tratando eventos como conex√£o, erro, e chamadas recebidas. Gerencia streams locais e remotos para chamadas de voz e v√≠deo.
    //
    // - **T√≥pico: Gerenciamento de Estado**
    //   - **Descri√ß√£o**: Gerencia estados para nome do usu√°rio, contatos, mensagens, conex√µes, chamadas ativas, e streams de m√≠dia. Usa `localStorage` para persist√™ncia de dados.
    //
    // - **T√≥pico: Envio e Recebimento de Dados**
    //   - **Descri√ß√£o**: Implementa fun√ß√µes para enviar mensagens, arquivos, e √°udios em peda√ßos (`sendChunkedData`), e para processar dados recebidos (`handleIncomingData`), incluindo mensagens, arquivos, e √°udios.
    //
    // - **T√≥pico: Chamadas de Voz e V√≠deo**
    //   - **Descri√ß√£o**: Inclui fun√ß√µes para iniciar e encerrar chamadas de voz (`startVoiceCall`, `endCall`) e alternar chamadas de v√≠deo (`toggleVideoCall`), gerenciando streams de m√≠dia e atualizando a interface.
    //
    // - **T√≥pico: Interface do Usu√°rio**
    //   - **Descri√ß√£o**: Renderiza o cabe√ßalho, informa√ß√µes do usu√°rio, ID do peer, cont√™iner de v√≠deo, chamadas de voz ativas, e alterna entre a tela de chat e a tela de contatos.
    //
    // PARTE 5: Componente Principal App
    const App = () => {
useEffect(() => {
  if (localStorage.getItem('modo') === 'dark') {
    document.body.classList.add('dark-mode');
    const btn = document.getElementById('darkModeBtn');
    if (btn) btn.textContent = '‚òÄÔ∏è';
  }
}, []);

const toggleDarkMode = () => {
  document.body.classList.toggle('dark-mode');
  const isDark = document.body.classList.contains('dark-mode');
  localStorage.setItem('modo', isDark ? 'dark' : 'light');
  const btn = document.getElementById('darkModeBtn');
  if (btn) btn.textContent = isDark ? '‚òÄÔ∏è' : 'üåô';
};

      console.log("App: Component rendering");
      const [peerId, setPeerId] = usePersistentId();
      const [userName, setUserName] = useState(() => localStorage.getItem('p2pUserName') || '');
      const [editingName, setEditingName] = useState(!localStorage.getItem('p2pUserName'));
      const [connections, setConnections] = useState([]);
      const [messages, setMessages] = useState(() => {
        const saved = localStorage.getItem(MESSAGES_STORAGE_KEY);
        try {
          const parsed = saved ? JSON.parse(saved) : [];
          return parsed.map((msg, index) => ({ ...msg, timestamp: msg.timestamp || Date.now() + index }));
        } catch (err) {
          console.error("Error parsing saved messages:", err);
          localStorage.removeItem(MESSAGES_STORAGE_KEY);
          return [];
        }
      });
      const [newMessage, setNewMessage] = useState('');
      const [showContacts, setShowContacts] = useState(false);
      const [contacts, setContacts] = useState(() => {
        const saved = localStorage.getItem('p2pContacts');
        try { return saved ? JSON.parse(saved) : []; }
        catch(e) { return []; }
      });
      const [activeCalls, setActiveCalls] = useState([]);
      const [remoteStreams, setRemoteStreams] = useState([]);
      const [error, setError] = useState(null);
      const [isLocalVideoVisible, setIsLocalVideoVisible] = useState(false);
      const [showEmojiPanel, setShowEmojiPanel] = useState(false);
      const [selectedContact, setSelectedContact] = useState(null);
      const [isPeerInitialized, setIsPeerInitialized] = useState(false);

      const peerInstance = useRef(null);
      const fileInputRef = useRef(null);
      const pendingFiles = useRef({});
      const audioRefs = useRef({});
      const videoRefs = useRef({});
      const localVideoRef = useRef(null);
      const localStreamsRef = useRef(new Map());
      const CHUNK_SIZE = 16 * 1024;

      const stopAndRemoveLocalStream = (peerId) => {
        const stream = localStreamsRef.current.get(peerId);
        if (stream) {
          stream.getTracks().forEach(track => track.stop());
          localStreamsRef.current.delete(peerId);
          console.log(`App: Stopped and removed local stream for call with ${peerId}`);
          if (localStreamsRef.current.size === 0) {
            setIsLocalVideoVisible(false);
            if (localVideoRef.current) localVideoRef.current.srcObject = null;
          } else {
            const firstActiveStream = localStreamsRef.current.values().next().value;
            if (localVideoRef.current && firstActiveStream) {
              localVideoRef.current.srcObject = firstActiveStream;
            }
          }
        }
      };

      useEffect(() => {
        if (!peerId) return;
        console.log("App: Initializing PeerJS with ID:", peerId);
        const peer = new Peer(peerId, {
  host: '0.peerjs.com', 
  port: 443, 
  secure: true,
  config: { 
    iceServers: [
      // Google STUN servers
      { urls: 'stun:stun.l.google.com:19302' },
      { urls: 'stun:stun1.l.google.com:19302' },
      { urls: 'stun:stun2.l.google.com:19302' },
      { urls: 'stun:stun3.l.google.com:19302' },
      { urls: 'stun:stun4.l.google.com:19302' },
      
      // Mais servidores Google
      { urls: 'stun:stun.google.com:19302' },
      { urls: 'stun:stun-1.google.com:19302' },
      { urls: 'stun:stun-2.google.com:19302' },
      { urls: 'stun:stun-3.google.com:19302' },
      { urls: 'stun:stun-4.google.com:19302' },
      
      // Servidores Google regionais
      { urls: 'stun:stun-us-west-1.google.com:19302' },
      { urls: 'stun:stun-us-east-1.google.com:19302' },
      { urls: 'stun:stun-us-central-1.google.com:19302' },
      { urls: 'stun:stun-us-south-1.google.com:19302' },
      { urls: 'stun:stun-eu-west-1.google.com:19302' },
      { urls: 'stun:stun-eu-central-1.google.com:19302' },
      { urls: 'stun:stun-asia-east-1.google.com:19302' },
      { urls: 'stun:stun-asia-northeast-1.google.com:19302' },
      { urls: 'stun:stun-asia-south-1.google.com:19302' },
      { urls: 'stun:stun-asia-southeast-1.google.com:19302' },
      
      // Mais varia√ß√µes de servidores Google
      { urls: 'stun:stun.goog:19302' },
      { urls: 'stun:stun-1.goog:19302' },
      { urls: 'stun:stun-2.goog:19302' },
      { urls: 'stun:stun-3.goog:19302' },
      { urls: 'stun:stun-4.goog:19302' },
      
      // Servi√ßos Google
      { urls: 'stun:stun.meet.google.com:19302' },
      { urls: 'stun:stun.hangouts.google.com:19302' },
      { urls: 'stun:stun.chrome.google.com:19302' },
      { urls: 'stun:stun.gmail.google.com:19302' },
      { urls: 'stun:stun.youtube.google.com:19302' },
      { urls: 'stun:stun.drive.google.com:19302' },
      { urls: 'stun:stun.docs.google.com:19302' },
      { urls: 'stun:stun.play.google.com:19302' },
      
      // Varia√ß√µes adicionais de Google
      { urls: 'stun:stun1.corp.google.com:19302' },
      { urls: 'stun:stun2.corp.google.com:19302' },
      { urls: 'stun:stun3.corp.google.com:19302' },
      { urls: 'stun:stun4.corp.google.com:19302' },
      { urls: 'stun:stun5.corp.google.com:19302' },
      { urls: 'stun:stun6.corp.google.com:19302' },
      { urls: 'stun:stun.px.google.com:19302' },
      { urls: 'stun:stun.gl.google.com:19302' },
      { urls: 'stun:stun.gvt1.com:19302' },
      { urls: 'stun:stun.gvt2.com:19302' },
      { urls: 'stun:stun.gvt3.com:19302' },
      
      // Mais servidores regionais do Google
      { urls: 'stun:stun-na-east.google.com:19302' },
      { urls: 'stun:stun-na-west.google.com:19302' },
      { urls: 'stun:stun-sa-east.google.com:19302' },
      { urls: 'stun:stun-eu-west.google.com:19302' },
      { urls: 'stun:stun-eu-east.google.com:19302' },
      { urls: 'stun:stun-asia-east.google.com:19302' },
      { urls: 'stun:stun-asia-west.google.com:19302' },
      { urls: 'stun:stun-asia-south.google.com:19302' },
      { urls: 'stun:stun-asia-north.google.com:19302' },
      { urls: 'stun:stun-australia.google.com:19302' },
      { urls: 'stun:stun-africa.google.com:19302' },
      
      // Mais varia√ß√µes de Google
      { urls: 'stun:stun.voice.google.ca:19302' },
      { urls: 'stun:stun.voice.google.mx:19302' },
      { urls: 'stun:stun.voice.google.co.uk:19302' },
      { urls: 'stun:stun.voice.google.de:19302' },
      { urls: 'stun:stun.voice.google.fr:19302' },
      { urls: 'stun:stun.voice.google.ru:19302' },
      { urls: 'stun:stun.voice.google.jp:19302' },
      { urls: 'stun:stun.voice.google.cn:19302' },
      { urls: 'stun:stun.voice.google.in:19302' },
      { urls: 'stun:stun.voice.google.com.br:19302' },
      
      // Mais servidores regionais do Google
      { urls: 'stun:stun.google.com.ar:19302' },
      { urls: 'stun:stun.google.com.au:19302' },
      { urls: 'stun:stun.google.co.jp:19302' },
      { urls: 'stun:stun.google.co.kr:19302' },
      { urls: 'stun:stun.google.co.nz:19302' },
      { urls: 'stun:stun.google.co.th:19302' },
      { urls: 'stun:stun.google.co.za:19302' },
      { urls: 'stun:stun.google.com.sg:19302' },
      { urls: 'stun:stun.google.com.tw:19302' },
      
      // Servidores STUN n√£o-Google
      { urls: 'stun:stun.ekiga.net:3478' },
      { urls: 'stun:stun.ideasip.com:3478' },
      { urls: 'stun:stun.schlund.de:3478' },
      { urls: 'stun:stun.voiparound.com:3478' },
      { urls: 'stun:stun.voipbuster.com:3478' },
      { urls: 'stun:stun.voipstunt.com:3478' },
      { urls: 'stun:stun.voxgratia.org:3478' },
      { urls: 'stun:stun.services.mozilla.com:3478' },
      { urls: 'stun:stun.stunprotocol.org:3478' },
      { urls: 'stun:stun.counterpath.com:3478' },
      { urls: 'stun:stun.12connect.com:3478' },
      { urls: 'stun:stun.callwithus.com:3478' },
      { urls: 'stun:stun.sipgate.net:3478' },
      { urls: 'stun:stun.sipgate.net:10000' },
      { urls: 'stun:stun.1und1.de:3478' },
      { urls: 'stun:stun.gmx.net:3478' },
      { urls: 'stun:stun.xten.com:3478' },
      { urls: 'stun:stun.nextcloud.com:3478' },
      { urls: 'stun:stun.sip.us:3478' },
      { urls: 'stun:stun.twt.it:3478' }
    ],
    sdpSemantics: 'unified-plan',
    iceTransportPolicy: 'all',
    bundlePolicy: 'max-bundle',
    rtcpMuxPolicy: 'require',
    iceCandidatePoolSize: 10
  },
  debug: 2
});
        peer.on('open', (id) => {
          console.log("PeerJS: Connected with ID:", id);
          setIsPeerInitialized(true);
        });

        peer.on('error', (err) => {
          console.error("PeerJS: Error:", err);
          if (err.type === 'unavailable-id') {
            console.log("PeerJS: ID unavailable, generating new ID...");
            const newId = generateNewId();
            localStorage.setItem(PEER_ID_STORAGE_KEY, newId);
            window.location.reload();
          } else if (err.type === 'peer-unavailable') {
            console.log("PeerJS: Peer unavailable, user is likely offline");
            alert("Usu√°rio offline");
          } else {
            setError(`Erro PeerJS: ${err.type}`);
          }
        });

        peer.on('connection', (conn) => {
          console.log("PeerJS: Incoming data connection from:", conn.peer);
          if (connections.some(c => c.peer === conn.peer)) {
            console.log("App: Connection handler already set up for", conn.peer);
            setConnections(prev => prev.map(c => c.peer === conn.peer ? conn : c));
            return;
          }

          conn.on('open', () => {
            console.log("PeerJS: Data connection opened with:", conn.peer);
            setConnections(prev => [...prev.filter(c => c.peer !== conn.peer), conn]);
          });

          conn.on('data', (data) => {
            console.log("PeerJS: Received data from:", conn.peer, data.type);
            handleIncomingData(data, conn.peer);
          });

          conn.on('close', () => {
            console.log("PeerJS: Data connection closed with:", conn.peer);
            setConnections(prev => prev.filter(c => c.peer !== conn.peer));
            endCall(conn.peer, 'video');
            endCall(conn.peer, 'voice');
          });

          conn.on('error', (err) => {
            console.error("PeerJS: Data connection error with:", conn.peer, err);
            setConnections(prev => prev.filter(c => c.peer !== conn.peer));
            endCall(conn.peer, 'video');
            endCall(conn.peer, 'voice');
          });
        });

        peer.on('call', async (call) => {
          const callType = call.metadata?.type || 'video';
          console.log(`PeerJS: Receiving ${callType} call from:`, call.peer);

          try {
            console.log(`PeerJS: Answering ${callType} call from:`, call.peer, "without local stream initially");
            call.answer(null);

            setActiveCalls(prev => [
              ...prev.filter(c => !(c.peerId === call.peer && c.type === callType)),
              {
                peerId: call.peer,
                call,
                localStream: null,
                type: callType,
                direction: 'incoming',
                isTemporaryStream: false
              }
            ]);

            call.on('stream', (remoteStream) => {
              console.log(`PeerJS: Received remote ${callType} stream from:`, call.peer);
              setRemoteStreams(prev => [
                ...prev.filter(s => !(s.peerId === call.peer && s.type === callType)),
                { peerId: call.peer, stream: remoteStream, type: callType }
              ]);
            });

            call.on('close', () => {
              console.log(`PeerJS: Incoming ${callType} call closed with:`, call.peer);
              endCall(call.peer, callType);
            });

            call.on('error', (err) => {
              console.error(`PeerJS: Error in incoming ${callType} call:`, err);
              endCall(call.peer, callType);
            });

          } catch (err) {
            console.error(`PeerJS: Error handling incoming ${callType} call:`, err);
            call.close();
            alert('Erro ao acessar c√¢mera/microfone: ' + err.message);
          }
        });

        peerInstance.current = peer;

        return () => {
          console.log("App: Cleaning up PeerJS connection and all streams");
          if (peerInstance.current) {
            peerInstance.current.destroy();
            peerInstance.current = null;
          }
          localStreamsRef.current.forEach((stream, peerId) => {
            stream.getTracks().forEach(track => track.stop());
            console.log(`App Cleanup: Stopped local stream for ${peerId}`);
          });
          localStreamsRef.current.clear();
          setActiveCalls([]);
          setRemoteStreams([]);
          setIsLocalVideoVisible(false);
          if (localVideoRef.current) localVideoRef.current.srcObject = null;
          setIsPeerInitialized(false);
        };
      }, [peerId]);

      const generateNewId = () => {
        const chars = 'ABCDEFGHJKMNPQRSTUVWXYZ23456789';
        const buffer = new Uint8Array(6);
        crypto.getRandomValues(buffer);
        return Array.from(buffer).map(b => chars[b % chars.length]).join('');
      };

      const getContactName = (pId) => contacts.find(c => c.peerId === pId)?.name || pId;

      const saveUserName = () => {
        if (userName.trim()) {
          localStorage.setItem('p2pUserName', userName);
          setEditingName(false);
        }
      };

      const formatTime = (date) => date.toLocaleTimeString('pt-BR');

      const connectToPeer = (peerIdToConnect) => {
        if (!peerIdToConnect || !peerInstance.current || !isPeerInitialized) {
          alert("Erro: Peer n√£o inicializado ou ID inv√°lido");
          return;
        }
        if (connections.some(conn => conn.peer === peerIdToConnect && conn.open)) {
          console.log("App: Already connected to", peerIdToConnect);
          return;
        }

        console.log("App: Attempting to connect to peer:", peerIdToConnect);
        try {
          const conn = peerInstance.current.connect(peerIdToConnect, { reliable: true });
          if (!conn) {
            throw new Error("N√£o foi poss√≠vel criar a conex√£o");
          }

          conn.on('open', () => {
            console.log("PeerJS: Connection opened with:", peerIdToConnect);
            setConnections(prev => [...prev.filter(c => c.peer !== peerIdToConnect), conn]);
          });

          conn.on('error', (err) => {
            console.error("PeerJS: Connection error with:", peerIdToConnect, err);
            setConnections(prev => prev.filter(c => c.peer !== peerIdToConnect));
            alert(`Erro ao conectar com ${getContactName(peerIdToConnect)}: ${err.message || 'Contato offline ou ID inv√°lido'}`);
          });

          conn.on('close', () => {
            console.log("PeerJS: Connection closed with:", peerIdToConnect);
            setConnections(prev => prev.filter(c => c.peer !== peerIdToConnect));
          });

          conn.on('data', (data) => {
            console.log("PeerJS: Received data from:", peerIdToConnect, data);
            handleIncomingData(data, peerIdToConnect);
          });
        } catch (err) {
          console.error("App: Error establishing data connection:", err);
          alert(`Erro ao conectar com ${getContactName(peerIdToConnect)}: ${err.message || 'Contato offline ou ID inv√°lido'}`);
        }
      };

      const handleIncomingData = (data, pId) => {
        console.log("App: Processing incoming data of type:", data.type, "from", pId);
        const timestamp = data.timestamp || Date.now();
        const messageTime = data.time || formatTime(new Date(timestamp));
        const baseMessage = {
          sender: pId,
          senderName: data.senderName || getContactName(pId),
          time: messageTime,
          direct: data.direct || false,
          timestamp: timestamp,
          recipient: data.direct ? 'you' : undefined
        };

        let messageToAdd = null;

        if (data.type === 'message') {
          messageToAdd = { ...baseMessage, text: data.text, type: 'text' };
        } else if (data.type === 'file-start') {
          pendingFiles.current[data.fileId] = {
            fileName: data.fileName,
            chunks: new Uint8Array(data.fileSize),
            receivedBytes: 0,
            totalSize: data.fileSize,
            fileType: data.fileType
          };
          messageToAdd = { ...baseMessage, fileId: data.fileId, fileName: data.fileName, type: 'file', receiving: true, progress: 0 };
        } else if (data.type === 'file-chunk') {
          const fileData = pendingFiles.current[data.fileId];
          if (fileData) {
            const chunk = data.chunk instanceof ArrayBuffer ? new Uint8Array(data.chunk) : new Uint8Array(Object.values(data.chunk));
            fileData.chunks.set(chunk, data.offset);
            fileData.receivedBytes += chunk.length;
            const progress = Math.min(100, Math.floor((fileData.receivedBytes / fileData.totalSize) * 100));
            setMessages(prev => prev.map(msg => msg.fileId === data.fileId ? { ...msg, progress } : msg));
            if (fileData.receivedBytes === fileData.totalSize) {
              const blob = new Blob([fileData.chunks], { type: fileData.fileType || 'application/octet-stream' });
              const url = URL.createObjectURL(blob);
              setMessages(prev => prev.map(msg => msg.fileId === data.fileId ? { ...msg, fileData: url, receiving: false, progress: 100 } : msg));
              delete pendingFiles.current[data.fileId];
            }
          }
          return;
        } else if (data.type === 'audio-start') {
          pendingFiles.current[data.audioId] = { chunks: new Uint8Array(data.audioSize), receivedBytes: 0, totalSize: data.audioSize };
          messageToAdd = { ...baseMessage, audioId: data.audioId, type: 'audio', receiving: true, progress: 0 };
        } else if (data.type === 'audio-chunk') {
          const audioData = pendingFiles.current[data.audioId];
          if (audioData) {
            const chunk = data.chunk instanceof ArrayBuffer ? new Uint8Array(data.chunk) : new Uint8Array(Object.values(data.chunk));
            audioData.chunks.set(chunk, data.offset);
            audioData.receivedBytes += chunk.length;
            const progress = Math.min(100, Math.floor((audioData.receivedBytes / audioData.totalSize) * 100));
            setMessages(prev => prev.map(msg => msg.audioId === data.audioId ? { ...msg, progress } : msg));
            if (audioData.receivedBytes === audioData.totalSize) {
              const blob = new Blob([audioData.chunks], { type: 'audio/webm' });
              const url = URL.createObjectURL(blob);
              setMessages(prev => prev.map(msg => msg.audioId === data.audioId ? { ...msg, audioData: url, receiving: false, progress: 100 } : msg));
              delete pendingFiles.current[data.audioId];
            }
          }
          return;
        }

        if (messageToAdd) {
          setMessages(prev => {
            const updated = [...prev, messageToAdd];
            if (messageToAdd.type === 'text' || messageToAdd.receiving) {
              localStorage.setItem(MESSAGES_STORAGE_KEY, JSON.stringify(updated));
            }
            return updated;
          });
        }
      };

      const sendChunkedData = (conn, idKey, dataBlob, typePrefix, metaData) => {
        const id = peerId + `_${typePrefix}_` + Date.now();
        const reader = new FileReader();
        let offset = 0;
        const timestamp = new Date();
        const formattedTime = formatTime(timestamp);
        const isFile = typePrefix === 'file';
        const localUrl = URL.createObjectURL(dataBlob);

        setMessages(prev => {
          const newMsg = {
            ...metaData,
            [idKey]: id,
            sender: 'you',
            recipient: conn.peer,
            senderName: userName,
            time: formattedTime,
            type: isFile ? 'file' : 'audio',
            sending: true,
            progress: 0,
            direct: true,
            timestamp: timestamp.getTime(),
            [isFile ? 'fileData' : 'audioData']: localUrl
          };
          const updated = [...prev, newMsg];
          localStorage.setItem(MESSAGES_STORAGE_KEY, JSON.stringify(updated));
          return updated;
        });

        try {
          conn.send({
            type: `${typePrefix}-start`,
            [idKey]: id,
            [isFile ? 'fileSize' : 'audioSize']: dataBlob.size,
            senderName: userName,
            time: formattedTime,
            direct: true,
            timestamp: timestamp.getTime(),
            ...(isFile && { fileName: metaData.fileName, fileType: dataBlob.type })
          });
        } catch (err) {
          console.error(`App: Error sending ${typePrefix}-start to`, conn.peer, err);
          alert(`Erro ao iniciar envio: ${err.message}`);
          setMessages(prev => prev.filter(msg => msg[idKey] !== id));
          return;
        }

        const readChunk = () => {
          const chunk = dataBlob.slice(offset, offset + CHUNK_SIZE);
          reader.readAsArrayBuffer(chunk);
        };

        reader.onload = (ev) => {
          if (!conn || !conn.open) {
            console.error("App: Connection closed while sending chunk to", conn.peer);
            alert(`Conex√£o perdida com ${getContactName(conn.peer)} durante o envio.`);
            setMessages(prev => prev.map(msg => msg[idKey] === id ? { ...msg, sending: false, progress: -1 } : msg));
            return;
          }
          const chunkBuffer = ev.target.result;
          try {
            conn.send({ type: `${typePrefix}-chunk`, [idKey]: id, chunk: chunkBuffer, offset: offset, direct: true });
            offset += chunkBuffer.byteLength;
            const progress = Math.min(100, Math.floor((offset / dataBlob.size) * 100));
            setMessages(prev => prev.map(msg => msg[idKey] === id ? { ...msg, progress } : msg));
            if (offset < dataBlob.size) {
              requestAnimationFrame(readChunk);
            } else {
              console.log(`App: ${typePrefix} sending complete for id ${id}`);
              setMessages(prev => {
                const updated = prev.map(msg => msg[idKey] === id ? { ...msg, sending: false, progress: 100 } : msg);
                localStorage.setItem(MESSAGES_STORAGE_KEY, JSON.stringify(updated));
                return updated;
              });
            }
          } catch (err) {
            console.error(`App: Error sending ${typePrefix} chunk to`, conn.peer, err);
            alert(`Erro ao enviar parte: ${err.message}`);
            setMessages(prev => prev.map(msg => msg[idKey] === id ? { ...msg, sending: false, progress: -1 } : msg));
          }
        };
        reader.onerror = (err) => {
          console.error(`App: Error reading ${typePrefix} blob:`, err);
          alert(`Erro ao ler dados: ${err.message}`);
          setMessages(prev => prev.map(msg => msg[idKey] === id ? { ...msg, sending: false, progress: -1 } : msg));
        };
        readChunk();
      };

      const handleFileChange = (e) => {
        if (!userName.trim()) {
          alert('Defina seu nome.');
          setEditingName(true);
          return;
        }
        if (!selectedContact) {
          alert('Selecione um contato.');
          return;
        }
        const file = e.target.files[0];
        if (!file) return;
        const conn = connections.find(c => c.peer === selectedContact);
        if (!conn || !conn.open) {
          alert(`Contato ${getContactName(selectedContact)} offline.`);
          return;
        }

        sendChunkedData(conn, 'fileId', file, 'file', { fileName: file.name });
        fileInputRef.current.value = '';
      };

      const handleAudioRecording = (audioBlob, targetContact) => {
        if (!userName.trim()) {
          alert('Defina seu nome.');
          setEditingName(true);
          return;
        }
        if (!targetContact) {
          alert('Selecione um contato.');
          return;
        }
        const conn = connections.find(c => c.peer === targetContact);
        if (!conn || !conn.open) {
          alert(`Contato ${getContactName(targetContact)} offline.`);
          return;
        }

        sendChunkedData(conn, 'audioId', audioBlob, 'audio', {});
      };

      const startVoiceCall = async (peerIdToCall) => {
        if (!peerInstance.current) {
          alert('Peer n√£o inicializado');
          return;
        }
        if (!peerIdToCall) {
          alert('Selecione um contato.');
          return;
        }
        if (activeCalls.some(c => c.peerId === peerIdToCall && c.type === 'voice')) return;
        const conn = connections.find(c => c.peer === peerIdToCall);
        if (!conn || !conn.open) {
          alert(`Contato ${getContactName(peerIdToCall)} offline.`);
          return;
        }

        try {
          console.log("App: Starting voice call with:", peerIdToCall);
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
          if (!stream) return;

          localStreamsRef.current.set(peerIdToCall + '_voice', stream);
          const call = peerInstance.current.call(peerIdToCall, stream, { metadata: { type: 'voice' } });

          setActiveCalls(prev => [
            ...prev,
            {
              peerId: peerIdToCall,
              call,
              localStream: stream,
              type: 'voice',
              direction: 'outgoing',
              isTemporaryStream: false
            }
          ]);

          call.on('stream', (remoteStream) => {
            console.log(`App: Received remote audio stream from:`, peerIdToCall);
            setRemoteStreams(prev => [
              ...prev.filter(s => !(s.peerId === peerIdToCall && s.type === 'voice')),
              { peerId: peerIdToCall, stream: remoteStream, type: 'voice' }
            ]);
          });
          call.on('close', () => {
            console.log("App: Voice call closed with:", peerIdToCall);
            endCall(peerIdToCall, 'voice');
          });
          call.on('error', (err) => {
            console.error('App: Error in voice call:', err);
            alert('Erro chamada de voz: ' + err.message);
            endCall(peerIdToCall, 'voice');
          });
        } catch (err) {
          console.error('App: Error starting voice call:', err);
          alert('Erro ao acessar microfone: ' + err.message);
        }
      };

      const toggleVideoCall = async (peerIdToCall) => {
        if (!peerInstance.current) {
          alert('Peer n√£o inicializado');
          return;
        }
        if (!peerIdToCall) {
          alert('Selecione um contato.');
          return;
        }

        const existingCall = activeCalls.find(c => c.peerId === peerIdToCall && c.type === 'video');
        const isSendingVideo = existingCall && existingCall.localStream;
        const conn = connections.find(c => c.peer === peerIdToCall);

        if (isSendingVideo) {
          console.log("App: Stopping local video stream for:", peerIdToCall);
          if (existingCall && existingCall.localStream) {
            existingCall.localStream.getTracks().forEach(track => track.stop());
            localStreamsRef.current.delete(peerIdToCall + '_video');
          }

          setActiveCalls(prev => prev.map(c => {
            if (c.peerId === peerIdToCall && c.type === 'video') {
              return { ...c, localStream: null };
            }
            return c;
          }));

          if (localStreamsRef.current.size === 0) {
            setIsLocalVideoVisible(false);
            if (localVideoRef.current) localVideoRef.current.srcObject = null;
          }

        } else {
          if (!conn || !conn.open) {
            alert(`Contato ${getContactName(peerIdToCall)} offline.`);
            return;
          }

          try {
            console.log("App: Getting video stream for:", peerIdToCall);
            const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
            if (!stream) return;

            localStreamsRef.current.set(peerIdToCall + '_video', stream);
            setIsLocalVideoVisible(true);
            if (localVideoRef.current) localVideoRef.current.srcObject = stream;

            if (existingCall) {
              console.log("App: Adding local stream to existing call with:", peerIdToCall);

              setActiveCalls(prev => prev.map(c => {
                if (c.peerId === peerIdToCall && c.type === 'video') {
                  return { ...c, localStream: stream };
                }
                return c;
              }));

              const call = peerInstance.current.call(peerIdToCall, stream, { metadata: { type: 'video' } });

              call.on('stream', (remoteStream) => {
                console.log(`App: Received remote video stream response from:`, peerIdToCall);
              });

              call.on('close', () => {
                console.log("App: Outgoing video stream call closed with:", peerIdToCall);
              });

              call.on('error', (err) => {
                console.error('App: Error in outgoing video stream call:', err);
              });

            } else {
              console.log("App: Starting new video call with:", peerIdToCall);
              const call = peerInstance.current.call(peerIdToCall, stream, { metadata: { type: 'video' } });

              setActiveCalls(prev => [
                ...prev.filter(c => !(c.peerId === peerIdToCall && c.type === 'video')),
                {
                  peerId: peerIdToCall,
                  call,
                  localStream: stream,
                  type: 'video',
                  direction: 'outgoing',
                  isTemporaryStream: false
                }
              ]);

              call.on('stream', (remoteStream) => {
                console.log(`App: Received remote video stream from:`, peerIdToCall);
                setRemoteStreams(prev => [
                  ...prev.filter(s => !(s.peerId === peerIdToCall && s.type === 'video')),
                  { peerId: peerIdToCall, stream: remoteStream, type: 'video' }
                ]);
              });

              call.on('close', () => {
                console.log("App: Video call closed with:", peerIdToCall);
                endCall(peerIdToCall, 'video');
              });

              call.on('error', (err) => {
                console.error('App: Error in video call:', err);
                alert('Erro chamada de v√≠deo: ' + err.message);
                endCall(peerIdToCall, 'video');
              });
            }
          } catch (err) {
            console.error('App: Error starting video call:', err);
            alert('Erro ao acessar c√¢mera/microfone: ' + err.message);
          }
        }
      };

      const endCall = (peerIdToEnd, callType) => {
        console.log(`App: Ending ${callType} call with:`, peerIdToEnd);
        const callData = activeCalls.find(c => c.peerId === peerIdToEnd && c.type === callType);

        if (callData) {
          if (callData.call) {
            callData.call.close();
          }
          if (callData.localStream) {
            callData.localStream.getTracks().forEach(track => track.stop());
            console.log(`App: Stopped local stream tracks for ${callType} call with ${peerIdToEnd}`);
            stopAndRemoveLocalStream(peerIdToEnd + '_' + callType);
          }
        }

        setActiveCalls(prev => prev.filter(c => !(c.peerId === peerIdToEnd && c.type === callType)));
        setRemoteStreams(prev => prev.filter(s => !(s.peerId === peerIdToEnd && s.type === callType)));

        const anyLocalVideoActive = Array.from(localStreamsRef.current.values()).some(
          stream => stream.getVideoTracks().some(t => t.readyState === 'live')
        );
        if (!anyLocalVideoActive) {
          setIsLocalVideoVisible(false);
          if (localVideoRef.current) localVideoRef.current.srcObject = null;
        } else if (
          isLocalVideoVisible &&
          (!localVideoRef.current?.srcObject?.active || localVideoRef.current?.srcObject === callData?.localStream)
        ) {
          const firstActiveStream = localStreamsRef.current.values().next().value;
          if (localVideoRef.current && firstActiveStream) {
            localVideoRef.current.srcObject = firstActiveStream;
          }
        }
      };

      const populateEmojiPanel = () => {
    const emojis = [
      "üòÄ", "üòÅ", "üòÇ", "ü§£", "üòÉ", "üòÑ", "üòÖ", "üòÜ", "üòâ", "üòä",
      "üòã", "üòé", "üòç", "üòò", "ü•∞", "üòó", "üòô", "üòö", "üôÇ", "ü§ó",
      "ü§©", "ü§î", "ü§®", "üòê", "üòë", "üò∂", "üôÑ", "üòè", "üò£", "üò•",
      "üòÆ", "ü§ê", "üò¥", "üò™", "üòµ", "üò§", "üò≠", "üò°", "ü§Ø", "ü•µ",
      "üëç", "üëé", "üëå", "‚úåÔ∏è", "ü§û", "üëã", "ü§ö", "üñêÔ∏è", "üëè", "üôå",
      "üëê", "ü§≤", "üôè", "üí™", "ü¶µ", "ü¶∂", "üëÇ", "üëÉ", "üß†", "ü´Ä",
      "üëÄ", "üëÅÔ∏è", "üßë‚Äçü¶∞", "üßë‚Äçü¶±", "üßë‚Äçü¶≥", "üßë‚Äçü¶≤", "üë∂", "üßí", "üë¶", "üëß",
      "üßë", "üë±‚Äç‚ôÇÔ∏è", "üë±‚Äç‚ôÄÔ∏è", "üßî", "üë®‚Äçü¶∞", "üë©‚Äçü¶∞", "üë®‚Äçü¶±", "üë©‚Äçü¶±", "üë®‚Äçü¶≥", "üë©‚Äçü¶≥",
      "üë®‚Äçü¶≤", "üë©‚Äçü¶≤", "üë©", "üë®", "üßì", "üë¥", "üëµ", "üôç‚Äç‚ôÇÔ∏è", "üôç‚Äç‚ôÄÔ∏è", "üôé‚Äç‚ôÇÔ∏è",
      "üôé‚Äç‚ôÄÔ∏è", "üôÖ‚Äç‚ôÇÔ∏è", "üôÖ‚Äç‚ôÄÔ∏è", "üôÜ‚Äç‚ôÇÔ∏è", "üôÜ‚Äç‚ôÄÔ∏è", "üíÅ‚Äç‚ôÇÔ∏è", "üíÅ‚Äç‚ôÄÔ∏è", "üôã‚Äç‚ôÇÔ∏è", "üôã‚Äç‚ôÄÔ∏è", "üßè‚Äç‚ôÇÔ∏è",
      "üßè‚Äç‚ôÄÔ∏è", "üôá‚Äç‚ôÇÔ∏è", "üôá‚Äç‚ôÄÔ∏è", "ü§¶‚Äç‚ôÇÔ∏è", "ü§¶‚Äç‚ôÄÔ∏è", "ü§∑‚Äç‚ôÇÔ∏è", "ü§∑‚Äç‚ôÄÔ∏è", "üßë‚Äç‚öïÔ∏è", "üë®‚Äç‚öïÔ∏è", "üë©‚Äç‚öïÔ∏è",
      "üßë‚Äçüéì", "üë®‚Äçüéì", "üë©‚Äçüéì", "üßë‚Äçüè´", "üë®‚Äçüè´", "üë©‚Äçüè´", "üßë‚Äç‚öñÔ∏è", "üë®‚Äç‚öñÔ∏è", "üë©‚Äç‚öñÔ∏è", "üßë‚Äçüåæ",
      "üë®‚Äçüåæ", "üë©‚Äçüåæ", "üßë‚Äçüç≥", "üë®‚Äçüç≥", "üë©‚Äçüç≥", "üßë‚Äçüîß", "üë®‚Äçüîß", "üë©‚Äçüîß", "üßë‚Äçüè≠", "üë®‚Äçüè≠",
      "üë©‚Äçüè≠", "üßë‚Äçüíº", "üë®‚Äçüíº", "üë©‚Äçüíº", "üßë‚Äçüî¨", "üë®‚Äçüî¨", "üë©‚Äçüî¨", "üßë‚Äçüíª", "üë®‚Äçüíª", "üë©‚Äçüíª",
      "üßë‚Äçüé§", "üë®‚Äçüé§", "üë©‚Äçüé§", "üßë‚Äçüé®", "üë®‚Äçüé®", "üë©‚Äçüé®", "üßë‚Äç‚úàÔ∏è", "üë®‚Äç‚úàÔ∏è", "üë©‚Äç‚úàÔ∏è", "üßë‚ÄçüöÄ",
      "üë®‚ÄçüöÄ", "üë©‚ÄçüöÄ", "üßë‚Äçüöí", "üë®‚Äçüöí", "üë©‚Äçüöí", "üëÆ‚Äç‚ôÇÔ∏è", "üëÆ‚Äç‚ôÄÔ∏è", "üïµÔ∏è‚Äç‚ôÇÔ∏è", "üïµÔ∏è‚Äç‚ôÄÔ∏è", "üíÇ‚Äç‚ôÇÔ∏è",
      "üíÇ‚Äç‚ôÄÔ∏è", "ü•∑", "üë∑‚Äç‚ôÇÔ∏è", "üë∑‚Äç‚ôÄÔ∏è", "ü§¥", "üë∏", "üë≥‚Äç‚ôÇÔ∏è", "üë≥‚Äç‚ôÄÔ∏è", "üë≤", "üßï",
      "ü§µ", "üë∞", "ü§∞", "ü§±", "üë©‚Äçüçº", "üë®‚Äçüçº", "üßë‚Äçüçº", "üßô‚Äç‚ôÇÔ∏è", "üßô‚Äç‚ôÄÔ∏è", "üßö‚Äç‚ôÇÔ∏è",
      "üßö‚Äç‚ôÄÔ∏è", "üßõ‚Äç‚ôÇÔ∏è", "üßõ‚Äç‚ôÄÔ∏è", "üßù‚Äç‚ôÇ", "üßù‚Äç‚ôÄÔ∏è", "üßû‚Äç‚ôÇÔ∏è", "üßû‚Äç‚ôÄÔ∏è", "üßú‚Äç‚ôÇÔ∏è", "üßú‚Äç‚ôÄÔ∏è", "üßù‚Äç‚ôÇÔ∏è",
      "üßù‚Äç‚ôÄÔ∏è", "üê∂", "üê±", "üê≠", "üêπ", "üê∞", "ü¶ä", "üêª", "üêº", "üê®",
      "üêØ", "ü¶Å", "üêÆ", "üê∑", "üêΩ", "üê∏", "üêµ", "üôà", "üôâ", "üôä",
      "üêí", "üêî", "üêß", "üê¶", "üê§", "üê£", "üê•", "ü¶Ü", "ü¶Ö", "ü¶â",
      "ü¶á", "üê∫", "üêó", "üê¥", "ü¶Ñ", "üêù", "üêõ", "ü¶ã", "üêå", "üêû",
      "üêú", "ü¶ó", "üï∑Ô∏è", "üï∏Ô∏è", "ü¶Ç", "üê¢", "üêç", "ü¶é", "ü¶ñ", "ü¶ï",
      "üêô", "ü¶ë", "ü¶ê", "ü¶û", "ü¶Ä", "üê°", "üê†", "üêü", "üê¨", "üê≥",
      "üêã", "ü¶à", "üêä", "üêÖ", "üêÜ", "ü¶í", "üêò", "ü¶è", "ü¶õ", "üê™",
      "üê´", "ü¶ò", "ü¶ô", "ü¶ú", "ü¶ö", "ü¶¢", "ü¶©", "üïäÔ∏è", "üêá", "ü¶ù",
      "ü¶°", "ü¶¶", "ü¶•", "ü¶®", "ü¶î", "ü¶ß", "ü¶£", "ü¶§", "ü¶•", "ü¶¨",
      "üçá", "üçà", "üçâ", "üçä", "üçã", "üçå", "üçç", "ü•≠", "üçé", "üçè",
      "üçê", "üçë", "üçí", "üçì", "ü•ù", "üçÖ", "ü••", "ü•ë", "üçÜ", "ü•î",
      "ü•ï", "üåΩ", "üå∂Ô∏è", "ü•í", "ü•¨", "ü•¶", "üßÑ", "üßÖ", "üçÑ", "ü•ú",
      "üå∞", "üçû", "ü•ê", "ü•ñ", "ü•®", "ü•Ø", "ü•û", "üßá", "üßÄ", "üçñ",
      "üçó", "ü•©", "ü•ì", "üçî", "üçü", "üçï", "üå≠", "ü•™", "üåÆ", "üåØ",
      "ü•ô", "üßÜ", "ü•ö", "üç≥", "ü•ò", "üç≤", "ü•£", "ü•ó", "üçø", "üßà",
      "üßÇ", "üç±", "üçò", "üçô", "üçö", "üçõ", "üçú", "üçù", "üç†", "üç¢",
      "üç£", "üç§", "üç•", "ü•Æ", "üç°", "ü•ü", "ü•†", "ü•°", "ü¶™", "üç¶",
      "üçß", "üç®", "üç©", "üç™", "üéÇ", "üç∞", "üßÅ", "ü•ß", "üç´", "üç¨",
      "üç≠", "üçÆ", "üçØ", "üçº", "ü•õ", "‚òï", "üçµ", "üç∂", "üçæ", "üç∑",
      "üç∏", "üçπ", "üç∫", "üçª", "ü•Ç", "ü•É", "ü•§", "üßÉ", "üßâ", "üßä",
      "ü•¢", "üçΩÔ∏è", "üç¥", "ü•Ñ", "üî™", "üè∫", "üåç", "üåé", "üåè", "üó∫Ô∏è",
      "üóæ", "üß≠", "üèîÔ∏è", "‚õ∞Ô∏è", "üåã", "üóª", "üèïÔ∏è", "üèñÔ∏è", "üèúÔ∏è", "üèùÔ∏è",
      "üèûÔ∏è", "üèüÔ∏è", "üèõÔ∏è", "üèóÔ∏è", "üß±", "üèòÔ∏è", "üèöÔ∏è", "üè†", "üè°", "üè¢",
      "üè£", "üè§", "üè•", "üè¶", "üè®", "üè©", "üè™", "üè´", "üè¨", "üè≠",
      "üèØ", "üè∞", "üíí", "üóº", "üóΩ", "‚õ™", "üïå", "üõï", "üïç", "‚õ©Ô∏è",
      "üïã", "‚õ≤", "‚õ∫", "üåÅ", "üåÉ", "üèôÔ∏è", "üåÑ", "üåÖ", "üåÜ", "üåá",
      "üåâ", "‚ô®Ô∏è", "üé†", "üé°", "üé¢", "üíà", "üé™", "üöÇ", "üöÉ", "üöÑ",
      "üöÖ", "üöÜ", "üöá", "üöà", "üöâ", "üöä", "üöù", "üöû", "üöã", "üöå",
      "üöç", "üöé", "üöê", "üöë", "üöí", "üöì", "üöî", "üöï", "üöñ", "üöó",
      "üöò", "üöô", "üõª", "üöö", "üöõ", "üöú", "üèéÔ∏è", "üèçÔ∏è", "üõµ", "üö≤",
      "üõ¥", "üõπ", "üõ∫", "üöç", "üõ∏", "üöÅ", "üõ©Ô∏è", "‚úàÔ∏è", "ü™Ç", "üí∫",
      "üö§", "üõ•Ô∏è", "üõ≥Ô∏è", "‚õ¥Ô∏è", "‚öì", "‚õΩ", "üö®", "üö•", "üö¶", "üõë",
      "üöß", "üóø", "üóΩ", "üóº", "üè∞", "üèØ", "üèüÔ∏è", "üé°", "üé¢", "üé†",
      "‚õ≤", "‚õ±Ô∏è", "üèñÔ∏è", "üèùÔ∏è", "üèúÔ∏è", "üåã", "‚õ∞Ô∏è", "üèîÔ∏è", "üóª", "üèïÔ∏è",
      "üõñ", "üè†", "üè°", "üèòÔ∏è", "üèöÔ∏è", "üè¢", "üè¨", "üè£", "üè§", "üè•",
      "üè¶", "üè®", "üè™", "üè´", "üè©", "üíí", "üèõÔ∏è", "‚õ™", "üïå", "üïç",
      "üõï", "‚õ©Ô∏è", "üïã", "üõù", "üõó", "ü™û", "ü™ü", "ü™ö", "ü™§", "ü™ì",
     
    ];

    return (
      <div className="emoji-panel">
        <div className="emoji-panel-header">Emojis</div>
        <div className="emoji-panel-content">
          {emojis.map((emoji, index) => (
            <span
              key={index}
              className="emoji-item"
              onClick={() => setNewMessage(prev => prev + emoji)}
            >
              {emoji}
            </span>
          ))}
        </div>
        <div className="emoji-panel-footer">
          <span className="barra-rolagem-label">Role para ver mais</span>
        </div>
      </div>
    );
  };

  if (error) {
    return (
      <div className="error-message">
        <h1>Erro</h1>
        <p>{error}</p>
        <button onClick={() => window.location.reload()}>Tentar novamente</button>
      </div>
    );
  }

  return (
    <div>
      <input type="file" ref={fileInputRef} style={{ display: 'none' }} onChange={handleFileChange} />
      <div className="app-header">
        <h1 className="app-title">Chat K10</h1>
        
<div className="header-buttons">
  <button onClick={() => setShowContacts(true)} className="header-button" title="Contatos">
    <i className="fas fa-address-book"></i>
  </button>
  <button onClick={toggleDarkMode} className="header-button" title="Modo Noturno" id="darkModeBtn">
    üåô
  </button>
</div>

      </div>

      <div className="user-info-container">
        {editingName ? (
          <div className="user-name-form">
            <input
              type="text"
              value={userName}
              onChange={(e) => setUserName(e.target.value)}
              placeholder="Digite seu nome"
              autoFocus
            />
            <button
              onClick={saveUserName}
              disabled={!userName.trim()}
            >
              Salvar
            </button>
          </div>
        ) : (
          <div style={{ display: 'flex', alignItems: 'center', gap: '10px' }}>
            <span className="username">{userName}</span>
            <button
              className="user-edit-button"
              onClick={() => setEditingName(true)}
            >
              Editar
            </button>
          </div>
        )}
      </div>

      <div className="peer-id-container">
        <span>Seu ID: {peerId}</span>
        <button
          onClick={() => {
            navigator.clipboard.writeText(peerId);
            alert('ID copiado para a √°rea de transfer√™ncia!');
          }}
        >
          Copiar
        </button>
      </div>

      {(remoteStreams.length > 0 || isLocalVideoVisible) && (
        <div className="video-container">
          {isLocalVideoVisible && (
            <div>
              <div className="video-label">Voc√™</div>
              <video
                className="local-video-player"
                ref={localVideoRef}
                autoPlay
                muted
              ></video>
            </div>
          )}
          {remoteStreams.map((streamData, index) => (
            streamData.type === 'video' && (
              <div key={index}>
                <div className="video-label">{getContactName(streamData.peerId)}</div>
                <video
                  className="video-player"
                  ref={el => videoRefs.current[streamData.peerId] = el}
                  autoPlay
                ></video>
              </div>
            )
          ))}
        </div>
      )}

      {activeCalls.map((call, index) => (
        call.type === 'voice' && (
          <div key={index} className="audio-call-container">
            <span>Chamada de voz com {getContactName(call.peerId)}</span>
            <button
              className="call-end-button"
              onClick={() => endCall(call.peerId, 'voice')}
            >
              Encerrar
            </button>
            <audio
              ref={el => audioRefs.current[call.peerId] = el}
              autoPlay
            ></audio>
          </div>
        )
      ))}

      {showContacts ? (
        <ContactsScreen
          contacts={contacts}
          setContacts={setContacts}
          onBack={() => setShowContacts(false)}
          onSelectContact={(peerId) => {
            connectToPeer(peerId);
            setSelectedContact(peerId);
            setShowContacts(false);
          }}
        />
      ) : (
        <UpdatedChatManager
          connections={connections}
          messages={messages}
          setMessages={setMessages}
          contacts={contacts}
          userName={userName}
          peerId={peerId}
          activeCalls={activeCalls}
          endCall={endCall}
          startVoiceCall={startVoiceCall}
          toggleVideoCall={toggleVideoCall}
          remoteStreams={remoteStreams}
          audioRefs={audioRefs}
          videoRefs={videoRefs}
          handleFileChange={handleFileChange}
          fileInputRef={fileInputRef}
          handleAudioRecording={handleAudioRecording}
          newMessage={newMessage}
          setNewMessage={setNewMessage}
          showEmojiPanel={showEmojiPanel}
          setShowEmojiPanel={setShowEmojiPanel}
          populateEmojiPanel={populateEmojiPanel}
          getContactName={getContactName}
          selectedContact={selectedContact}
          setSelectedContact={setSelectedContact}
          localVideoRef={localVideoRef}
        />
      )}
    </div>
  );
};

// Renderiza√ß√£o do aplicativo
ReactDOM.render(
  <ErrorBoundary>
    <App />
  </ErrorBoundary>,
  document.getElementById('root')
);

</script>
</body>
</html>







